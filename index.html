<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>pdf.js ローカル最小テスト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 14px;
      margin: 8px;
    }
    h1{
      font-size: 18px;
      margin: 0 0 8px;
    }
    .info{
      font-size: 12px;
      color:#555;
      line-height:1.4;
      margin-bottom:8px;
    }
    #log{
      font-family: "Consolas","Menlo",monospace;
      font-size: 12px;
      background:#000;
      color:#0f0;
      padding:4px;
      height:220px;
      overflow:auto;
      white-space:pre-wrap;
      border-radius:4px;
      margin-top:8px;
    }
    #pdfCanvas{
      border:1px solid #ccc;
      margin-top:8px;
      max-width:100%;
    }
  </style>
</head>
<body>
  <h1>pdf.js ローカル最小テスト</h1>
  <div class="info">
    v2025.11.21-test / Edge95 file:// 想定<br>
    同じフォルダに <code>test_pdf.html</code> と <code>pdf.min.js</code> を置いてください。
  </div>

  <div>
    <label>PDFファイル選択：
      <input type="file" id="fileInput" accept="application/pdf">
    </label>
  </div>

  <canvas id="pdfCanvas"></canvas>
  <div id="log"></div>

  <!-- [LIB-01] Edge95 用 structuredClone ポリフィル（pdf.min.js より前） -->
  <script>
    if (typeof window.structuredClone !== "function") {
      // Edge95 には structuredClone がないので、単純なダミー実装にする。
      // disableWorker:true で main thread だけで動かす前提なので、
      // 「コピーではなく同じ参照を返す」だけで十分です。
      window.structuredClone = function (value) {
        return value;
      };
    }
  </script>

  <!-- [LIB-02] ローカル版 pdf.js 読み込み（同じフォルダに pdf.min.js があること） -->
  <script src="pdf.min.js"></script>

  <!-- [APP-01] テスト本体スクリプト -->
  <script>
    const logEl = document.getElementById("log");
    const canvas = document.getElementById("pdfCanvas");
    const ctx = canvas.getContext("2d");

    function log(msg){
      logEl.textContent += msg + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }

    // 起動時ログ
    (function initLog(){
      log("OK: pdf.min.js 読み込み完了？ pdfjsLib.version = " + (window.pdfjsLib && pdfjsLib.version));
      log("location.protocol = " + location.protocol + " （file:// 想定）");
      log("備考: worker は完全に使わず、main thread だけで描画させます。");
      log("");
    })();

    document.getElementById("fileInput").addEventListener("change", async (ev) => {
      const file = ev.target.files[0];
      if (!file) return;

      log("--- PDF読み込み開始 ---");
      log("ファイル名: " + file.name + " / サイズ: " + file.size + " bytes");

      try{
        const arrayBuffer = await file.arrayBuffer();

        // ★ ここがポイント：disableWorker:true で worker 無効
        const loadingTask = pdfjsLib.getDocument({
          data: arrayBuffer,
          disableWorker: true
        });

        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);

        const viewport = page.getViewport({ scale: 1.2 });
        canvas.width  = viewport.width;
        canvas.height = viewport.height;

        const renderCtx = { canvasContext: ctx, viewport };
        await page.render(renderCtx).promise;

        log("ページ1の描画が完了しました。");
        log("--- PDFテスト終了 ---");
      } catch (e){
        console.error(e);
        log("ERROR: PDF読み込みまたは描画中に例外が発生しました。");
        log(String(e && e.message || e));
        log("--- PDFテスト終了 ---");
      }
    });
  </script>
</body>
</html>
